import logging
import re
from collections import defaultdict
from typing import Any

from faker import Faker


class SQLFaker:
    def __init__(
        self,
        db_name: str,
        arguments: list[str],
        count: int,
        generate_ids: bool,
        id_field_name: str,
    ) -> None:
        self.faker = Faker()
        self.arguments = arguments
        self.count = count
        self.db_name = db_name
        self.generate_ids = generate_ids
        self.id_field_name = id_field_name or "id"

        self.generated = defaultdict(list)
        self.command: str = ""

        self.generate()

    def generate(self):
        self._generate()
        self._build()

    def _generate(self):
        for _ in range(0, self.count):
            for argument in self.arguments:
                if ":" in argument:
                    self._parse_named_argument(argument)
                else:
                    self._generate_faker_value(argument, argument)

    def _parse_named_argument(self, argument: str) -> None:
        name, value = argument.split(":", 1)
        if value.isalpha():
            self._parse_alpha_argument(name, value)
        else:
            self._parse_choice_value(name, value)

    def _parse_alpha_argument(self, name: str, value: str) -> None:
        if value == "bool":
            self._generate_bool(name)
        else:
            self._generate_faker_value(name, value)

    def _parse_choice_value(self, name: str, value: str) -> None:
        if ":" in value:
            bounds = value.split(":")
            assert len(bounds) == 2
            bounds = sorted(int(b.strip("[]")) for b in bounds)
            self._generate_range(name, *bounds)
        elif "," in value:
            choices = re.findall(r"([a-zA-Z0-9].+?),", value)
            assert len(choices) > 0
            choices = [b.strip() for b in choices]
            choices = [int(b) for b in choices if b.isnumeric()]
            self._generate_pick(name, choices)
        else:
            self._generate_same_value(name, int(value))

    def _generate_faker_value(self, name: str, value: str) -> None:
        try:
            value = self.faker.__getattr__(value)()
            self.generated[name].append(value)
        except AttributeError:
            logging.warning(
                f"No fixture for {value} can be generated by Faker. Trying to generate using mockaroo"
            )

    def _generate_bool(self, name: str) -> None:
        self.generated[name].append(self.faker.pybool())

    def _generate_same_value(self, name: str, value: int) -> None:
        self.generated[name].append(value)

    def _generate_range(self, name: str, lb: int, ub: int) -> None:
        self.generated[name].append(self.faker.pyint(lb, ub))

    def _generate_pick(self, name: str, choices: list[Any]) -> None:
        index = self.faker.pyint(0, len(choices) - 1)
        self.generated[name].append(choices[index])

    def _build(self) -> None:
        self.command = "\n".join(
            (
                "INSERT INTO "
                + f"{self.db_name} ({self.id_field_name + ', ' if self.generate_ids else ''}{', '.join(key for key in self.generated.keys())})"
                + " VALUES",
                ",\n".join(
                    f"({str(index+1) + ', ' if self.generate_ids else ''}{value})"
                    for index, value in enumerate(list(self.generated.values())[0])
                )
                + ";",
            )
        )

    def print(self):
        print(self.command)

    def write(self, file):
        print(file)
        print(self.command)

    def copy(self):
        pass
